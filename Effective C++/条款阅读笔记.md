
_ _ _
## 引言

### 基本但需明确的定义

| 序号 | 内容 |
|--------|--------|
|1| **声明式**： 只是告诉编译器对象的名称和类型。但略去细节，即为发生内存分配和赋初值。|
|   2   | **size_t**. size_t是C++计算个数时用的某种不带正负号（unsigned）类型。它被用于基于字符指针的字符串数组内表示字符的个数，也被用于vector,deque,string等STL哦容器的operator[] 函数所接受的参数类型。      |
|3| **函数签名**：函数的声明揭示其签名式，也就是函数的返回类型和参数类型。函数的签名也就是函数的类型。|
|4|**定义式**：提供编译器一些声明式所遗漏的细节。对对象来说，定义式是编译器为对象拨发内存。对于函数，函数模板来说，定义式提供代码本体。对于类和类模板来说，定义式列出它们的成员。|
|5|**初始化**：给予对象初值的过程。对于自定义类型，调用构造函数。默认构造函数要么没有参数，要不全部参数都有缺省值。|
|6|**构造函数的explicit声明**：防止调用构造函数时发生隐式类型转换，这样增加用户不可控的风险。使之必须显式类型转换才行。|
|7|**拷贝构造函数和拷贝赋值运算符重载**：在带有指针成员的类，必须给出自定义的拷贝构造函数和拷贝赋值运算符重载函数，因为编译器提供的默认版本不能对指针申请的内存有效释放，造成内存泄漏。注意：区分两者的关键在于看有无新对象被定义。`Widget w3 = w2;`调用的是拷贝构造函数，=语言也可以用来调用拷贝构造函数；在传参pass by value时，会调用拷贝构造函数，所以拷贝构造函数的参数应该声明为引用类型，否则在传参时陷入无限调用拷贝构造函数的死循环中，最终内存溢出。两者都返回引用类型。在拷贝赋值运算符重载函数的定义中，要先检查有无自赋值的情况，`if(this == &param) return *this;`,然后先释放指针指向的旧内存，再申请新内存，拷贝内容。|
|8|**不确定性行为**：空指针解引用，数组超出索引在C++中会导致的是不确定的行为，这与其他程不同。意味着，有时会正常，有时会崩溃，有时产生不正确的结果。|
|9|接口：C++中没有明确的接口概念。书中的接口是指函数签名或者是class中可访问的元素（pubic接口，protected接口，private接口）|


### 条款1 视C++为一个语言联邦
包含4个次语言
- C -局限：没有模板，异常，重载...
- Objected-Oriented C++
- Template C++
- STL

所遵循的守则在每个次语言不一定都一致。

### 条款2 尽量以const, enum, inline替换 #define
宁以编译器替换预处理器

| 序号 | 内容 |
|--------|--------|
|   1     | `#define ASPECT_RATIO 1.653` -> `const double AspectRatio = 1.653` 原因ASPECT_RATIO可能因为没进入符号表造成编译错误，此时错误指示的是1.653而非ASPECT_RATIO，造成调试错误也相当麻烦。后者因为是变量（常量），肯定会进入符号表，且产生的代码量也比前者小。|
|1.1|在1中，如果是常量指针（区别于指针所指之物是常量），定义为`const char* const authorName = "Scott Meyers"`,更推荐使用string而非char*-based字符串，`const std::string authorName("Scott Meyers")`|
|1.2|在1中，class的专属常量，应定为` static const int Numbers = 5;` static确保常量只有一个实体，且static和const的位置前后随意。注意：这只是一个声明式，即便同时给出了初值。要在实现文件中给出定义式， `const int Object::Numbers;` 此时才发生内存的分配。如果没有定义式，则可以使用，但是不能出现取该变量地址的操作，否则会报错。最后，在声明时已经给出初值，所以在定义式中不能再设初值。总的来说，希望通过这个例子，弄明白声明，定义，赋初值间的关系。旧的编译器可能不支持static成员在声明式上获得初值，此时应该在定义式上赋初值。|
|1.2.1|万一编译器不允许static成员常量在声明时完成in class初值设定，而这个初始值又用来在编译时声明一个数组，编译器在编译时期必须知道数组的大小（非new）,造成失败。此时，可以使用“the enum hack”，其理论基础：一个枚举类型的数值可权充int被使用。-> `enum {Numbers = 5}; //令Numbers成为5的一个记号名称。int scores(Numbers);`|
|1.3|#define不重视作用域，一旦宏被定义，在其后的编译过程都有效，除非某处#undef。也不能提供任何封装性。所以#define不能用来定义class的专属常量。|

### 条款3 尽可能使用const  建议此条款反复阅读
const关键字允许指定一个语义约束，即一个不可改动的对象，而编译器会强制实施这个约束。

| 序号 | 内容 |
|--------|--------|
|    1    |   区分指向常量的指针和指针常量。`char greeting[] = "hello"; //指向常量的指针 const char* p = greeting; //常量指针 char* const p = greeting; //指向常量的常量指针 const char* const p = greeting;` 关键字const出现在星号左边，表示被指物常量，如果出现在星号右边，表示指针自身是常量。如果出现在星号两边，表示被指物和指针两者都是常量。如果被指物是常量，则关键字const写在类型之前或之后，星号之前，两者写法的意义相同。`const Widget* pw vs Widget const * pw`|
|2|STL迭代器以指针为根据塑模出来，所以迭代器的作用就像个T*指针。声明迭代器为const，就像声明指针为const一样，即迭代器不能再指向别的东西，但是指向的东西的值可以被改变。如果希望指向的东西的值不可改变，则需要要const_iterator.示例：`const std::vector<int>::iterator iter = vec.begin();`//表示迭代器不能再指向别的东西，即 T&#10052; const。 `std::vector<int>::iterator cIter = vec.begin();`//迭代器指向对象的内容不可改变，即const T&#10052;。|
|3|const最具威力的用法：与函数声明的连用。可以与返回值，各参数，函数自身（成员函数）相关联。**总之，除非你有需要改动参数或local对象，否则请将它们声明为const**。1.给函数返回值声明为const, 意味着函数返回值不能再修改，可以防止错误使用=，一是if(fun(a) = b)的书写错误，甚至出现隐式类型变换转为bool,使错误更难发现,二是（a*b）=c，a&#10052;b是operator*函数，=会调用operator=。|
|4|const用于成员函数，即表示函数内不能修改对象的数据成员。声明为const就可以很清楚的知道，哪些函数可以改动对象内容，哪些不可以。第二，使得操作const对象称为可能。因为const对象不允许修改内容，如果想用引用的方式传参，则不能修改函数参数。|
|5|mutable(可变的)释放掉non-static成员变量的bitwise constness约束。即，在维护对象不可变的整体效果下（客户的角度），允许修改一些不重要的变量，让编译器能够接受。|
|6|注意返回值的方式，是by-value还是by-reference。在operator[]函数，如果定义返回是by-value，就会出现arr[i]=1;修改的是副本，而非arr对象。|
|7|如果两个成员函数只是常量性不同，它们符合函数重载的条件。意味着编译器会根据调用时的常量性选择合适的函数。|
|8|常量性移除：令non-const成员函数调用其const兄弟是避免代码重复的安全做法。需要执行一个转型动作。|
![](条款3-0.png)



- - -

## 构造、析构、赋值运算

### 条款5 了解C++默认的构造，析构，赋值函数
| 序号 | 内容 |
|--------|--------|
|    1    |   默认的构造函数都是public, inline。只有当这些函数被需要时（调用），才会被编译器创建出来。     |

